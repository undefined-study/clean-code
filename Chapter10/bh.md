# 10장. 클래스

### 클래스 체계

정적, 공개 상수부터 정적 비공개 변수, 비공개 인스턴스 변수와
공개 함수가 나오는 추상화 단계가 순차적으로 내려가는 구조로서
프로그램이 신문 기사처럼 읽힌다.

#### 캡슐화

### 클래스는 작아야 한다!

함수는 물리적인 행 수로 크기를 측정하지만, 클래스는 맡은 책임으로 그 크기를 센다.
함수와 마찬가지로 클래스 또한 그 크기가 작아야 한다.
여기서, 클래스 이름을 정할 때 간결한 이름이 떠오르지 않는다면, 클래스 크기가 너무 크고
책임이 많다는 증거이다.

#### 단일 책임 원칙

만능 클래스보다는 하나의 일을 책임지고 잘 추상화 해내는 클래스가 되어야 한다.
단일 책임 원칙을 지키면, 그 클래스나 모듈을 변경할 이유는 단 하나가 된다.
즉, 변경할 이유를 파악하고 줄이다보면 코드를 추상화하기 쉬워진다.

소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동은
완전 별개이다. 돌아가는 소프트웨어를 만들게 하는 것은 전적으로 올바른 태도이다.
하지만, 돌아가는 소프트웨어를 만들고 나서 그게 끝이라고 생각하는 것은 잘못된 태도이다.

복잡성을 다루려면, 체계적인 정리가 필수이다. 그래야 개발자가 무엇이 어디에 있는지
쉽게 찾을 수 있고 이후 유지보수에 용이해진다.
큰 클래스 몇 개가 아니라, 작은 클래스 여러개가 더 바람직하다.

#### 응집도

메서드와 변수가 서로 의존하며 논리적인 단위로 묶이는 클래스는
응집도가 높다. 몇몇 메서드만이 사용하는 인스턴스 변수가 많다면,
심중팔구 새로운 클래스로 쪼개야 한다는 신호이다.

#### 응집도를 유지하면 작은 클래스 여럿이 나온다

몇몇 함수만이 사용하는 몇몇 변수가 생긴다면, 독자적인 클래스로 쪼개라!
...쪼개느라 늘어난 코드는 당연히 따라오는 것이다.(?)

### 변경하기 쉬운 클래스

클래스에 손대어 고쳐야 하는 문제를 위해 손을 대면 위험이 생기는 것.
클래스에 손대면 다른 코드를 망가뜨릴 잠정적인 위험이 존재한다.
기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.

#### 변경으로부터 격리

상세한 구현에 의존하는 클라이언트 코드는 테스트가 어렵고 구현도 어렵다.
테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱
높아진다. 결합도를 낮추면 변경으로부터 잘 격리된다.

### 참고 문헌
