# [13장] 동시성

## 📚 목차
- 동시성이 필요한 이유?
    - 미신과 오해
- 난관
- 동시성 방어 원칙
    - 단일 책임 원칙
    - 따름 정리: 자료 범위를 제한하라
    - 따름 정리: 자료 사본을 사용하라
    - 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 라이브러리를 이해하라
    - 스레드 환경에 안전한 컬렉션
- 실행 모델을 이해하라
    - 생산자-소비자
    - 읽기-쓰기
    - 식사하는 철학자들
- 동기화하는 메서드 사이에서 존재하는 의존성을 이해하라
- 동기화하는 부분을 작게 만들어라
- 올바른 종료 코드는 구현하기 어렵다
- 스레드 코드 테스트하기
    - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
    - 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
    - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
    - 프로세서 수보다 많은 스레드를 돌려보라
    - 다른 플랫폼에서 돌려보라
    - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
    - 직접 구현하기
    - 자동화
- 결론
- 참고 문헌

---

동시성과 깔끔한 코드는 양립하기 어렵다.

### 🔍 실행 모델을 이해하라
- 스레드 관련 기본 용어들
    - 한정된 자원: 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.
    - 상호 배제: 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
    - 기아: 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자우너을 기다린다.
    - 데드락: 여러 스레드가 서로를 끝나기를 기다린다.
    - 라이브락: 락을 거는 단계에서 각 스레드가 서로를 방해한다.

- #### [생산자-소비자](https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C)
    생산자-소비자 문제는 여러 개의 프로세스를 어떻게 동기화할 것인가에 관한 고전적인 문제이다.   
    유한한 개수의 물건(데이터)을 임시로 보관하는 보관함(버퍼)에 여러 명의 생산자들과 소비자들이 접근한다. 생산자는 물건이 하나 만들어지면 그 공간에 저장한다. 이때 저장할 공간이 없는 문제가 발생할 수 있다. 소비자는 물건이 필요할 때 보관함에서 물건을 하나 가져온다. 이 때는 소비할 물건이 없는 문제가 발생할 수 있다.
- #### [읽기-쓰기](https://ko.wikipedia.org/wiki/%EB%8F%85%EC%9E%90-%EC%A0%80%EC%9E%90_%EB%AC%B8%EC%A0%9C)
    읽기-쓰기 문제는 여러 명의 독자와 저자들이 하나의 저장 공간(버퍼)을 공유하며 이를 접근할 때 발생하는 문제이다.   
    독자는 공유 공간에서 데이터를 읽어온다. 여러 명의 독자가 동시에 데이터를 읽어오는 것이 가능하다. 저자는 공유 공간에 데이터를 쓴다. 한 저자가 공유 공간에 데이터를 쓰고 있는 동안에는 그 저자만 접근이 가능하며, 다른 독자들과 저자들은 접근할 수 없다.
- #### [식사하는 철학자들](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)
    식사하는 철학자들 문제는 동시성과 교착 상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.   
    다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 포크가 하나씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 포크를 동시에 들어야 한다.    
    이때 각각의 철학자가 왼쪽의 포크를 들고 그 다음 오른쪽의 포크를 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자는 동시에 왼쪽의 포크를 들 수 있으나 오른쪽의 포크는 이미 가져가진 상태이기 때문에 다섯 명 모두가 무한정 서로를 기다리는 교착 상태에 빠지게 될 수 있다. 또한 어떤 경우에는 동시에 양쪽 포크를 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

### 💡 [세마포어](https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4)
세마포어는 두 개의 원자적 함수로 조작되는 정수 변수로서, 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법으로 사용된다. 이는 철학자들의 만찬 문제의 고전적인 해법이지만 모든 교착 상태를 해결하지는 못한다.   
세마포어 S는 정수값을 가지는 변수이며, P(try)와 V(increment)라는 명령에 의해서만 접근할 수 있다.   
P는 임계 구역에 들어가기 전에 수행되고, V는 임계 구역에서 나올 때 수행된다. 이때 한 프로세스(또는 스레드)에서 세마포어 값을 변경하는 동안 다른 프로세스가 동시에 이 값을 변경해서는 안 된다.


### 💡 [임계구역](https://ko.wikipedia.org/wiki/%EC%9E%84%EA%B3%84_%EA%B5%AC%EC%97%AD)
임계 구역은 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부를 말한다.  
임계 구역은 지정된 시간이 지난 후 종료된다. 때문에 어떤 스레드(태스크 또는 프로세스)가 임계 구역에 들어가고자 한다면 지정된 시간만큼 대기해야 한다. 스레드가 공유자원의 배타적인 사용을 보장받기 위해서 임계 구역에 들어가거나 나올때는 세마포어 같은 동기화 매커니즘이 사용된다.
```java
do {
      wait(mutex);   //입장 구역: 임계 구역에 진입허가를 요청하는 구역
      ** 임계 구역 **
      signal(mutex); //퇴장 구역: 임계 구역을 빠져나왔음을 알리는 구역
      나머지 구역
}
```