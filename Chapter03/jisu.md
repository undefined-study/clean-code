# [3장] 함수

## 📚 목차
- 작게 만들어라!   
    - 블록과 들여쓰기   
- 한 가지만 해라!   
    - 함수 내 섹션   
- 함수 당 추상화 수준은 하나로!   
    - 위에서 아래로 코드 읽기: 내려가기 규칙
- Switch 문   
- 서술적인 이름을 사용하라!   
- 함수 인수   
    - 많이 쓰는 단항 형식   
    - 플래그 인수   
    - 이항 함수   
    - 삼항 함수   
    - 인수 객체   
    - 인수 목록    
    - 동사와 키워드   
- 부수 효과를 일으키지 마라!   
    - 출력 인수   
- 명령과 조회를 분리하라!   
- 오류 코드보다 예외를 사용하라!  
    - Try/Catch 블록 뽑아내기   
    - 오류 처리도 한 가지 작업이다.   
    - Error.java 의존성 자석    
- 반복하지 마라!   
- 구조적 프로그래밍   
- 함수를 어떻게 짜죠?   
- 결론

---

### 🔍 작게 만들어라!   
함수는 작을 수록 좋다.   
중첩 구조가 생길만큼 함수가 커져서는 안된다.   

### 🔍 한 가지만 해라!   
함수는 한 가지를 해야한다. 그 한 가지를 잘 해야 한다.   
- **한 가지만 하는지** 판단하는 방법   
    - 지정된 함수 이름 아래에서 [추상화 수준](https://onestone-dev.tistory.com/3)이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
    - 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
    - 한 가지만 하는 함수는 그 내부를 섹션으로 나누기 어렵다.

### 🔍 함수 당 추상화 수준은 하나로!   
함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.   
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.  
- #### **내려가기** 규칙   
    위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.

### 🔍 Switch 문
Switch 문은 작게 만들기 어려우나 [다형성](https://ko.wikipedia.org/wiki/%EB%8B%A4%ED%98%95%EC%84%B1_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))을 이용하면 저차원 클래스에 숨기고 반복하지 않아도 된다.   

### 🔍 서술적인 이름을 사용하라!
함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.   
길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.   
여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.   
일관성 있게 이름을 붙여야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

### 🔍 함수 인수
함수에서 이상적인 인수 개수는 0개(무항)다.
인수는 개념을 이해하기 어렵게 만든다.   
테스트 관점에서 보면 인수는 더 어렵다.   
- #### 플래그 인수   
    플래그 인수는 추하다. 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까!   
- #### 인수 객체    
    인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.   
- #### 동사와 키워드   
    단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다. 또는 함수 이름에 인수 이름을 넣어 인수 순서를 기억할 필요가 없도록 한다.   

### 🔍 부수 효과를 일으키지 마라!
함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하는 부수 효과는 거짓말이다.   
부수 효과는 시간적인 결합이나 순서 종속성을 초래한다.   
- #### [출력 인수](https://velog.io/@sansam202/Output-Parameter%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)   
    보통은 인수를 함수 **입력**으로 해석하므로 인수를 출력으로 사용하는 함수는 인지적으로 거슬리기 때문에 피해야 한다.   
    객체 지향 언어에서는 **this**가 있기 때문에 출력 인수를 사용할 필요가 없다.   
    함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식(member method)을 택한다.

### 🔍 명령과 조회를 분리하라!
함수는 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나만 해야 한다.

### 🔍 오류 코드보다 예외를 사용하라! 
오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 하기 때문에 코드가 더러워진다.   
반면에 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되어 깔끔해진다.
- #### Try/Catch 블록 뽑아내기   
    try/catch 블록을 별도 함수로 뽑아내어 정상 동작과 오류 처리 동작을 분리하는게 좋다.   
- #### 오류 처리도 한 가지 작업이다.   
    오류를 처리하는 함수도 오류만 처리해야 마땅하다.   
- #### Error.java 의존성 자석   
    오류 코드를 반환한다는 이야기는 어디선가 오류 코드를 정의한다는 뜻이다. 이는 곧 오류 코드를 변경하려면 재컴파일/재배치가 필요하다.   
    반면 예외를 사용하면 Exception 클래스에서 예외가 파생되기 때문에 새 예외 클래스를 추가해도 재컴파일/재배치가 필요 없다.

### 🔍 반복하지 마라!
코드가 중복되면 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 손 봐야 할 곳이 늘어난다. 게다가 어느 한곳이라도 빠뜨리면 오류가 발생할 확률도 높아진다.

### 🔍 구조적 프로그래밍
모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.  
위의 규칙은 함수가 작을 때보다 아주 클 때 이익을 제공한다.

### 🔍 함수를 어떻게 짜죠?
코드를 짜는 것은 여느 글짓기와 비슷하다. 처음부터 좋은 함수를 짤 수 있는 사람은 없다.   
좋은 함수가 나올 때까지 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서도 바꾸고 전체 클래스를 쪼개기도 한다. 이 과정에서도 단위 테스트는 항상 통과해야 한다.   

### 🔍 결론
시스템은 구현할 프로그램이 아니라 **풀어갈 이야기**이다.   
좋은 함수를 만드는 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다. 좋은 함수는 이야기를 잘 풀어갈수 있도록 도와준다. 
