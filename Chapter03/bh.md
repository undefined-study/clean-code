# 3장. 함수

### 작게 만들어라!

함수는 명백하게 각 함수가 이야기 하나를 표현해야 한다.

#### 블록과 들여쓰기

if, else, while 문의 바디는 한줄이어야 하며 대개 거기서 함수를 호출해야 한다.
또한, 블록 안의 이야기를 함수 이름으로 적절히 짓는다면 코드를 이해하기도 쉬워진다.

### 한 가지만 해라!

함수는 한 가지만 해야 하며 한 가지를 잘해야 한다.
단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면
그 함수는 여러 작업을 하는 셈이다.

#### 함수 내 섹션

섹션으로 쉽게 분리되는 함수는 여러 작업을 하고 있다는 증거이다.
한가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

### 함수 당 추상화 수준은 하나로!

'한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

이야기처럼 읽혀야 좋다. 함수는 추상화 단계별로 중첩 함수를 이룬다.

### Switch 문

### 서술적인 이름을 사용하라!

한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이미 절반은 성공이다.
함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.

이름은 길어도 된다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋으며 이는 주석을 사용한 것보다 좋다.
물론, 이름을 정하느라 시간을 들여도 괜찮다. 이름을 넣어 코드를 읽어보고 서술적인 흐름을 판단하면 더 좋다.

### 함수 인수

테스트 측면에서 인수가 많으면 많을수록 테스트하기가 상당히 부담스러워진다.
출력 인수는 입력 인수보다 이해하기 어렵다.

#### 많이 쓰는 단항 형식

함수에 인자가 하나인 경우가 좋은 이유는 마치 함수에게 질문을 던지는 구조로 해석하기 좋다.
가령 `boolean fileExists('MyFiles')` 는 'MyFiles이 존재해?' 라고 질문하는 구조이다.

#### 플래그 인수

함수로 boolean 값을 전달하는 것은 끔찍하다. 함수가 한꺼번에 여러 가지를
처리한다고 대놓고 공표하는 셈이다.

#### 이항 함수

#### 삼항 함수

#### 인수 객체

인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자.

#### 인수 목록

#### 동사와 키워드

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필요하다.
함수 이름의 키워드를 추가하여 인수 순서 또한 표현한다.
`assertExpectedEqualsActual(expected, actual)`는 인수 순서를 표현한 좋은 예시이다.

### 부수 효과를 일으키지 마라!

순수한 함수를 지향하자. 한 가지만 하겠다고 약속한 함수에서 외부 환경에 변경을 부수적으로 일으킨다면
혼란이 커진다.

#### 출력 인수

### 명령과 조회를 분리하라!

특정 동작을 수행하거나, 답을 주거나 둘 중 하나만 하도록 한다.

### 오류 코드보다 예외를 사용하라!

#### Try/Catch 블록 뽑아내기

try catch 코드 구조에서 정상동작과 에러동작을 구분지어 함수로 뽑아내어
동작의 뒤섞임을 방지한다.

#### 오류 처리도 한 가지 작업이다.

#### Error.java 의존성 자석

### 반복하지 마라!

코드 길이가 늘어날 뿐 아니라, 알고리즘 변경에 따라 반복되는 곳
모두 손을 봐야 한다.

객체 지향 프로그래밍은 코드를 부모 클래스로 몰아 중복을 없앤다.

### 구조적 프로그래밍

함수는 입구와 출구는 하나만 존재해야 한다. 함수를 작게만들기 위해
사용된 return, break, continue의 사용은 의도를 표현하기 더 쉬워진다.

### 함수를 어떻게 짜죠?

길고 복잡하며 중복된 루프 그리고 많은 인수 목록을 사용하고,
함수 이름까지 즉흥적이다. 이를 지속적으로 쪼개고 다듬고 코드의 흐름에 맞추어
이름도 수정하고 중복을 제거하는 것으로 규칙을 만족하는 함수가 얻어진다.

### 결론

결국, 시스셈이라는 이야기를 풀어나가는 데 있어 분명하고 깔끔한 전개가
맞아떨어질 때 이야기를 풀어나가기 쉽가는 것을 기억하자.
